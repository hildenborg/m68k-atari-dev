From 4a6c2b939efe68b05476fd8002f9c0a5d01295d5 Mon Sep 17 00:00:00 2001
From: Mikael Hildenborg <micael@hildenborg.com>
Date: Fri, 22 Aug 2025 08:13:39 +0200
Subject: [PATCH 4/4] m68k-atari-elf: proper setup of environment variables and
 program arguments.

---
 libgloss/m68k/atari/atari-crt0.S    |  55 +-----
 libgloss/m68k/atari/atari-crti.S    |  36 +++-
 libgloss/m68k/atari/atari-environ.c | 267 +++++++++++++++++++++++++++-
 3 files changed, 302 insertions(+), 56 deletions(-)

diff --git a/libgloss/m68k/atari/atari-crt0.S b/libgloss/m68k/atari/atari-crt0.S
index 6d1bbd1d9..882be54b0 100644
--- a/libgloss/m68k/atari/atari-crt0.S
+++ b/libgloss/m68k/atari/atari-crt0.S
@@ -4,55 +4,20 @@
 */
 
 	.global exit
+	.global _atari_argv		| in atari-environ.c
+	.global _atari_argc		| in atari-environ.c
 
 	.section	".init"
 	.global	__call_main_with_argc_argv
 	.type	__call_main_with_argc_argv,#function
 __call_main_with_argc_argv:
 
-/*
-	Need to implement "The Atari Extended Argument Specification".
-	Also, there is no guarantee that the command line is zero terminated.
-*/
     | this occurs after crtbegin.o have done all global constructors etc.
-
-	move.l	a7, a6
-	moveq	#0, d0
-	moveq	#0, d2
-	movea.l	_BasePage, a0
-	lea		128(a0), a0		| add offset to the cmdline
-	lea		_cmdline, a1
-	move.b	(a0)+, d2		| d2 contains number of bytes in command line (max 127)
-	beq.s	3f
-	clr.b	(a1, d2.w)		| end our decoded args with a zero.
-	bra.s	2f
-1:
-	move.b	(a0, d2.w), d1
-	cmp.b	#' ', d1
-	bne.s	4f
-	moveq	#0, d1
-	lea		1(a1, d2.w), a2
-	tst.b	(a2)
-	beq.s	4f
-	move.l	a2, -(a7)
-	addq.w	#1, d0
-4:
-	move.b	d1, (a1, d2.w)
-2:
-	subq.w	#1, d2
-	bcc.s	1b
-	move.l	a1, -(a7)
-	addq.w	#1, d0
-3:
-	pea		_procname		| first argument is always the proc name. That we do not know...
-	addq.w	#1, d0
-	move.l	a7, a5
-	move.l	a6, -(a7)		| To know where to move it back again.
-
-	move.l	a5, -(a7)		| argv
-	move.l	d0, -(a7)		| argc
+	| atari-crti.S have already set up _atari_argc, _atari_argv
+	move.l	_atari_argv, -(a7)
+	move.l	_atari_argc, -(a7)
 	jsr		main
-	move.l	8(a7), a7		| move it back.
+	addq.l	#8, a7
 	move.l	d0, -(a7)
 	jsr		exit			| not expected to return
 	illegal
@@ -64,11 +29,3 @@ _exit:
 	move.w	d0, _program_return_code
     | crtend.o follows here with global destructors etc.
 
-	.data
-_procname:
-	.asciz	"yourapp.lol"
-	.even
-
-	.bss
-	.lcomm	_cmdline, 128
-	.even
diff --git a/libgloss/m68k/atari/atari-crti.S b/libgloss/m68k/atari/atari-crti.S
index e11c51cba..caecacef0 100644
--- a/libgloss/m68k/atari/atari-crti.S
+++ b/libgloss/m68k/atari/atari-crti.S
@@ -15,6 +15,7 @@
 	.global _HeapPtr
 	.global _heapbase
 	.global _atari_4ba_at_prg_start
+	.global _atari_4be_at_prg_start
 	.global __BSS_SEGMENT_END
 
 	.section	".init"
@@ -24,6 +25,21 @@ _init:
 	move.l	4(a7),a0
 	move.l	a0, _BasePage
 
+/*
+	First do a quick jump into supervisor mode to get some needed pointers.
+*/
+	move.l	#super_init, -(a7)
+	move.w	#0x26, -(a7)
+	trap	#14
+	addq.l	#6, a7
+
+/*
+	Make an estimate for how much memory we need to reserve for environment and arguments.
+*/
+	jsr		estimate_env_and_args_memory				| in atari-environ.c
+	| d0 contains the number of bytes we need to reserve for environment and arguments.
+	move.l	d0, d7
+	
 /*
 	Init stack and heap.
 	The size of the stack and heap together is specified in _stksize.
@@ -38,11 +54,14 @@ _init:
 		if _stksize < -1, then use -_stksize memory.
 */
 	lea		__BSS_SEGMENT_END, a2
+	add.l	d7, a2			| environment and arguments
 	move.l	a2, _heapbase
 	move.l	a2, _HeapPtr
 
+	move.l	_BasePage, a0
 	move.l	4(a0), d1		| mem top
 	sub.l	a2, d1			| free mem
+	move.l	d1, d6
 	lea		_stksize, a1
 	cmpa.w	#0, a1
 	jeq		stksize_selected
@@ -72,6 +91,13 @@ stksize_above_three:
 	move.l	d0, d1
 stksize_selected:
 
+	| adjust for memory needed for environment and arguments
+	add.l	d7, d1
+	cmp.l	d1, d6
+	jpl		1f
+	move.l	d6, d1
+1:
+
 	add.l	a2, d1
 	bclr	#0, d1		| even address.
 	move.l	d1, a7
@@ -94,12 +120,13 @@ stksize_selected:
 super_init:
 	| Init stuff that needs supervisor mode set.
 	move.l	0x4ba, _atari_4ba_at_prg_start
+	move.l	0x4be, _atari_4be_at_prg_start
 	rts
 heap_setup_done:
-	move.l	#super_init, -(a7)
-	move.w	#0x26, -(a7)
-	trap	#14
-	addq.l	#6, a7
+
+	pea		__BSS_SEGMENT_END				| storage space for environment and arguments
+	jsr		setup_env_and_args				| in atari-environ.c
+
     | crtbegin.o follows here with global constructors etc. init.
 
 
@@ -114,4 +141,5 @@ heap_setup_done:
 	.lcomm 	_HeapPtr, 4
 	.lcomm 	_heapbase, 4
 	.lcomm	_atari_4ba_at_prg_start, 4
+	.lcomm	_atari_4be_at_prg_start, 4
 	.even
\ No newline at end of file
diff --git a/libgloss/m68k/atari/atari-environ.c b/libgloss/m68k/atari/atari-environ.c
index 3f4970733..5588c2885 100644
--- a/libgloss/m68k/atari/atari-environ.c
+++ b/libgloss/m68k/atari/atari-environ.c
@@ -3,6 +3,267 @@
 	SPDX-License-Identifier: BSD-2-Clause
 */
 
-// Should point to a list of global environment variables.
-char *__env[1] = { 0 };
-char **environ = __env;
\ No newline at end of file
+#include "atari-gem_basepage.h"
+
+/*
+	The functions:
+		void setup_env_and_args(void *mem_ptr)
+		int estimate_env_and_args_memory(void)
+	are called from atari-crti.S and should be handled with care.
+*/
+
+extern char **environ;		// setup_env_and_args will set this up.
+
+// Atari TOS do not supply any method of finding out the name of the application that is running.
+// So we default a name here to have a proper arg1.
+const char _proc_name[] = "_undefin.ed_";
+
+extern const char* _atari_4be_at_prg_start;	// Global environment
+const char **_atari_argv;
+int _atari_argc;
+
+// If storage_list is 0, then vars is only counted.
+// If argv_arg is not 0, then the value of ARGV= is stored there if found.
+int extract_env_vars(const char* env, const char** storage_list, const char** argv_arg)
+{
+	int num = 0;
+	if (env != 0)
+	{
+		// If we find a double null without a previous '=', then the string from the last var
+		// up to the double null must be discarded (aes bug).
+		while (env[0] != 0)		// loop until double null (string beginning with null)
+		{
+			const char* cvar = env;
+			short found_equal = 0;
+			short len_since_equal = 0;
+			while (env[0] != 0)
+			{
+				if (found_equal != 0) {++len_since_equal;}
+				if (env[0] == '=') {found_equal = 1;}
+				++env;
+			}
+			++env;
+			if (found_equal == 0 || len_since_equal == 0)
+			{
+				// This string is not valid, we should ignore it.
+				if (env[0] == 0)
+				{
+					// Double null after invalid string, ignore it.
+					++env;
+				}
+			}
+			else
+			{
+				if (argv_arg != 0 && (env - cvar) > 5 && 
+					(cvar[0] == 'A' && cvar[1] == 'R' && cvar[2] == 'G' && cvar[3] == 'V' && cvar[4] == '='))
+				{
+					*argv_arg = cvar + 5;
+					// We do not count ARGV as it is a part of command line.
+				}
+				else
+				{
+					if (storage_list != 0)
+					{
+						storage_list[num] = cvar;
+					}
+					++num;
+				}
+			}
+		}
+	}
+	return num;
+}
+
+int extract_cmd_args(const char* prg_cmd_line, const char* argv_arg, int* cmd_line_chars, const char** storage_list, char* cmd_line_out)
+{
+	int num = 0;
+	if (storage_list != 0)
+	{
+		storage_list[num] = _proc_name; 
+	}
+	++num;
+
+	int cmd_line_len = ((const unsigned char*)prg_cmd_line)[0];
+	cmd_line_chars[0] = 0;
+	if (cmd_line_len == 0)
+	{
+		return num;
+	}
+	if (cmd_line_len != 127)
+	{
+		// Only use ARGV if length is 127
+		argv_arg = 0;
+	}
+
+	const char* cmdline = prg_cmd_line + 1;
+	char expect = 0;
+	char *arg_start = cmd_line_out;
+	int arglen = 0;
+	while (cmdline != 0)
+	{
+		char c;
+		while ((c = *cmdline++) != 0)
+		{
+			if (c == '\\' && expect == 0)
+			{
+				// Next char will be escaped.
+				expect = '\\';
+			}
+			else if ((c == '\'' || c == '\"') && (expect == c || expect == 0))
+			{
+				// chars between "" or '' should not be escaped nor spaces split into args.
+				expect ^= c;
+			}
+			else if (c == ' ' && expect == 0)
+			{
+				if (arglen != 0)
+				{
+					// found one arg
+					if (cmd_line_out != 0) {*cmd_line_out++ = 0;}
+					cmd_line_chars[0]++;
+					if (storage_list != 0)
+					{
+						storage_list[num] = arg_start; 
+					}
+					++num;
+					arglen = 0;	// Next arg
+					arg_start = cmd_line_out;
+				}
+			}
+			else
+			{
+				if (expect == '\\')
+				{
+					// Only escape one char.
+					expect = 0;
+				}
+				if (cmd_line_out != 0) {*cmd_line_out++ = c;}
+				cmd_line_chars[0]++;
+				++arglen;
+			}
+		}
+
+		// Continue with extended command line if we have one.
+		cmdline = argv_arg;
+		argv_arg = 0;	// To end loop
+	}
+	if (arglen != 0)
+	{
+		if (cmd_line_out != 0) {*cmd_line_out++ = 0;}
+		cmd_line_chars[0]++;
+		if (storage_list != 0)
+		{
+			storage_list[num] = arg_start; 
+		}
+		++num;
+	}
+	return num;
+}
+
+/*
+prg_cmd_line:
+	First byte = length of prg_cmd_line.
+	If length == 127 then "ARGV=" in prg_env contains a string that should be appended to prg_cmd_line.
+prg_env:
+	Contains a set of null terminated strings.
+	Double null ends set.
+global_env:
+	Contains a set of null terminated strings.
+	Double null ends set.
+	AES versions >= 1.4 may multi-args (PATH) with ',', before it was only ';'
+	A bug in AES can cause strings like: "PATH=[nul]A:\[nul][nul]". They should be ignored.
+
+Due to how existing software sets up environment variables on Atari, global_env and prg_env can
+contain duplicates.
+So duplicates will be discarded with prg_env having higher priority than global_env.
+*/
+void setup_env_and_args(void *mem_ptr)
+{
+	/*
+		mem_ptr is guaranteed have the number of bytes reserved that function
+		estimate_env_and_args_memory calculates.
+	*/
+	const char* argv_arg = 0;
+	const char* prg_cmd_line = _BasePage->p_cmdlin;
+	const char* prg_env = _BasePage->p_env;
+	const char* global_env = _atari_4be_at_prg_start;
+
+	// Collect all environment variables.
+	environ = (char**)mem_ptr;
+	int num_env_args = extract_env_vars(prg_env, (const char**)environ, &argv_arg);
+	num_env_args += extract_env_vars(global_env, (const char**)environ, 0);
+	/*
+		Remove duplicates.
+		Not fun as we cannot use any library functions here.
+	*/
+	for (int i = 0; i < num_env_args; ++i)
+	{
+		char* vari = environ[i];
+		if (vari != 0)
+		{
+			for (int j = i + 1; j < num_env_args; ++j)
+			{
+				char* varj = environ[j];
+				if (varj != 0)
+				{
+					char* tvari = vari;
+					while (*tvari == *varj && *tvari != 0 && *tvari != '=')
+					{
+						++tvari;
+						++varj;
+					}
+					if (*tvari == '=' && *varj == '=')
+					{
+						// Found duplicate, clear it with a null pointer.
+						environ[j] = 0;
+					}
+				}
+			}
+		}
+	}
+	// Remove all null variables.
+	int new_num_env_args = 0;
+	for (int i = 0; i < num_env_args; ++i)
+	{
+		if (environ[i] != 0)
+		{
+			environ[new_num_env_args++] = environ[i];
+		}	
+	}
+	environ[new_num_env_args++] = 0;
+
+	// Count command line args
+	int cmd_line_chars = 0;
+	int num_cmd_args = extract_cmd_args(prg_cmd_line, argv_arg, &cmd_line_chars, 0, 0);
+
+	_atari_argv = (const char**)environ + new_num_env_args;
+	char* cmd_line_out = (char*)(_atari_argv + num_cmd_args + 1); 
+	// Collect all command line args.
+	_atari_argc = extract_cmd_args(prg_cmd_line, argv_arg, &cmd_line_chars, _atari_argv, cmd_line_out);
+	_atari_argv[_atari_argc] = 0;
+}
+
+int estimate_env_and_args_memory(void)
+{
+	/*
+		Stack and heap are not properly set up when this function is called.
+		NO memory allocations or large stack usage allowed!
+	*/
+	const char* argv_arg = 0;
+	const char* prg_cmd_line = _BasePage->p_cmdlin;
+	const char* prg_env = _BasePage->p_env;
+	const char* global_env = _atari_4be_at_prg_start;
+
+	int num_env_args = extract_env_vars(prg_env, 0, &argv_arg);
+	num_env_args += extract_env_vars(global_env, 0, 0);
+	int cmd_line_chars = 0;
+	int num_cmd_args = extract_cmd_args(prg_cmd_line, argv_arg, &cmd_line_chars, 0, 0);
+
+	int bytes_to_reserve = (num_env_args + 1) * 4;
+	bytes_to_reserve += (num_cmd_args + 1) * 4;
+	bytes_to_reserve += cmd_line_chars;
+
+	// This is the number of bytes of heap space that will be reserved before
+	// stack and heap is initialized. 
+	return bytes_to_reserve;
+}
\ No newline at end of file
-- 
2.43.0

