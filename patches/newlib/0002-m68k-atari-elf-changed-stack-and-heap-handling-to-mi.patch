From 44ecacdc9b33379e239c51736eb259ada84feaff Mon Sep 17 00:00:00 2001
From: Mikael Hildenborg <micael@hildenborg.com>
Date: Wed, 13 Aug 2025 18:15:34 +0200
Subject: [PATCH 2/2] m68k-atari-elf: changed stack and heap handling to mimic
 mintlib.

---
 libgloss/m68k/atari/atari-crti.S | 83 +++++++++++++++++++++-----------
 libgloss/m68k/atari/atari-sbrk.c | 18 +++++--
 2 files changed, 70 insertions(+), 31 deletions(-)

diff --git a/libgloss/m68k/atari/atari-crti.S b/libgloss/m68k/atari/atari-crti.S
index 5e4c13b0e..e11c51cba 100644
--- a/libgloss/m68k/atari/atari-crti.S
+++ b/libgloss/m68k/atari/atari-crti.S
@@ -8,14 +8,12 @@
 #define _fini	__libc_fini_array
 #endif
 
-	.equ	DEFAULT_STACK, 2000
+	.equ	MINKEEP, 0x10000
 
 	.global _BasePage
-	.weak 	_STACK_SIZE
-	.weak 	_HEAP_SIZE
+	.weak 	_stksize
 	.global _HeapPtr
-	.global _HeapBottom
-	.global _HeapTop
+	.global _heapbase
 	.global _atari_4ba_at_prg_start
 	.global __BSS_SEGMENT_END
 
@@ -26,32 +24,62 @@ _init:
 	move.l	4(a7),a0
 	move.l	a0, _BasePage
 
-	| Init stack
+/*
+	Init stack and heap.
+	The size of the stack and heap together is specified in _stksize.
+	The stack is set to point at the top of the reserved memory.
+	The heap is set to point at the bottom of the reserved memory.
+	Usage of _stksize (mintlib functionally compatible):
+		if _stksize is undefined, then all available memory is used.
+		if _stksize is 0, then MINKEEP memory is used.
+		if _stksize > 0 && < 4, then _stksize/4 of all memory is used.
+		if _stksize >= 4, then use that much memory.
+		if _stksize == -1, then all available memory is used.
+		if _stksize < -1, then use -_stksize memory.
+*/
 	lea		__BSS_SEGMENT_END, a2
-	lea		_STACK_SIZE, a1
+	move.l	a2, _heapbase
+	move.l	a2, _HeapPtr
+
+	move.l	4(a0), d1		| mem top
+	sub.l	a2, d1			| free mem
+	lea		_stksize, a1
 	cmpa.w	#0, a1
-	jeq		default_stack_size
-	add.l	(a1), a2
-	jra		stack_size_selected
-default_stack_size:
-	lea		DEFAULT_STACK(a2), a2
-stack_size_selected:
-	move.l	a2, a7
+	jeq		stksize_selected
+	move.l	(a1), d0
+	jeq		stksize_zero
+	jmi		stksize_negative
+stksize_positive:
+	moveq	#4, d2
+	cmp.l	d2, d0
+	jpl		stksize_above_three
+stksize_one_to_three:
+	lsr.l	#2, d1
+	move.l	d1, d2
+1:
+	subq.w	#1, d0
+	jeq		stksize_selected
+	add.l	d2, d1
+	jra		1b
+stksize_zero:
+	move.l	#MINKEEP, d1
+	jra		stksize_selected
+stksize_negative:
+	not.l	d0
+	jeq		stksize_selected	| -1
+	addq.l	#1, d0				| d0 = -_stksize
+stksize_above_three:
+	move.l	d0, d1
+stksize_selected:
 
-	| Init heap
-	move.l	a7, d0
-	move.l	d0, _HeapBottom
-	move.l	d0, _HeapPtr
-	move.l	4(a0), _HeapTop
+	add.l	a2, d1
+	bclr	#0, d1		| even address.
+	move.l	d1, a7
 
-	lea		_HEAP_SIZE, a1
-	cmpa.w	#0, a1
-	jeq		heap_setup_done
-	add.l	(a1), d0
-	sub.l	(a0), d0			| d0 is now the TPA size
+	sub.l	a0, d1		| mem from basepage to top.
 
-	| Program do not want all memory, so we shrink it.
-	move.l	d0, -(a7)
+	| Shrink mem.
+	move.l	d1, -(a7)
 	move.l	a0, -(a7)
 	clr.w	-(a7)
 	move.w	#0x4a, -(a7)	| Mshrink()
@@ -84,7 +112,6 @@ heap_setup_done:
 	.bss
 	.lcomm 	_BasePage, 4
 	.lcomm 	_HeapPtr, 4
-	.lcomm 	_HeapBottom, 4
-	.lcomm 	_HeapTop, 4
+	.lcomm 	_heapbase, 4
 	.lcomm	_atari_4ba_at_prg_start, 4
 	.even
\ No newline at end of file
diff --git a/libgloss/m68k/atari/atari-sbrk.c b/libgloss/m68k/atari/atari-sbrk.c
index 8839cc742..535395f3e 100644
--- a/libgloss/m68k/atari/atari-sbrk.c
+++ b/libgloss/m68k/atari/atari-sbrk.c
@@ -7,13 +7,25 @@
 #include <_ansi.h>
 
 extern char *_HeapPtr;
-extern char *_HeapBottom;
-extern char *_HeapTop;
+extern char *_heapbase;
 
 char *sbrk(int nbytes)
 {
 	char *newheap = _HeapPtr + nbytes;
-	if (newheap > _HeapTop)
+
+	/*
+		The user stack pointer is the top heap.
+		The behaviour is undefined if we are in supervisor mode.
+		But memory allocations in supervisor mode feels like a bad idea anyway.
+	*/
+	char *heaptop;
+	__asm__ volatile (
+		"move.l	%%a7, %0\n\t"
+		: "=g" (heaptop)
+		:
+		:);
+
+	if (newheap > heaptop)
 	{
 		errno = ENOMEM;
 		return ((char *)-1);
-- 
2.43.0

